<html>
<head>
  <title>The Abstraction: The Process</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/301769 (en-US); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="895"/>
<h1>The Abstraction: The Process</h1>

<div>
<span><div><span style="font-size: 19px;"><u><b>The Abstraction: The Process</b></u></span></div><div>A <b>process</b> is, informally, a <strong>running program.</strong> </div><ul><li>A program is just a bunch of instructions, the OS is what turns it into something useful.</li></ul><div><span style="text-decoration: underline;">How to provide the illusion of many CPUs?</span></div><ul><li>The OS creates the illusion by <strong>virtualizing</strong> the CPU.<br clear="none"/></li><li style="list-style: none; display: inline"><ul><li>If the OS runs one process, stops it, then runs another and so on and so forth then the OS can promote the illusion that many virtual CPUs exist when there is only one <strong>physical </strong>CPU (or a few).</li><li>This is <strong>time sharing</strong> which allows users to run many concurrent processes (at the cost of performance)<br clear="none"/></li></ul></li></ul><div><br clear="none"/></div><div>To implement virtualization, you need both high-level intelligence (<strong>policies </strong>- which are an algorithm to make decisions in the OS such as a <strong>scheduling policy</strong>) and low-level machinery (<strong>mechanisms </strong> - which implement a needed piece of functionality such as a <strong>context switch</strong>)</div><ul><li>We can summarize a process by taking an inventory of the different pieces of the system it accesses or affects during the course of its execution.<br clear="none"/></li><li>To understand what constitutes a <strong>process</strong>, we have to understand its <strong>machine state</strong> (what a program can read or update when it is running)</li><li style="list-style: none; display: inline"><ul><li>At a given time, what parts of the machine are important to the execution of this program?<br clear="none"/></li><li>One component of <strong>machine state </strong>is <strong>memory</strong>. Instructions lie in memory, the data that is read and written sits in memory as well. </li><li>The memory that the process can address, the <strong>address space</strong>, is part of the process.</li><li>A second part of the <strong>machine state</strong> are <strong>registers.</strong> Many instructions read or update registers so registers are important to the execution of the process. (Useful registers: <strong>Program Counter, Frame Pointer and Stack Pointer</strong>)</li><li>Programs often access storage devices too; <strong>I/O information</strong> might include a list of the files the process has open</li></ul></li></ul><div><strong>Pro Tip: </strong>In many OS's, a common design paradigm is to separate high-level policies from their low-level mechanisms. Mechanisms provide the answer to a <b>how</b> question (<b>How </b>does an OS perform a context switch?) and the policies answer <strong>which </strong>questions (<strong>which </strong>process should the OS run right now?).<br clear="none"/></div><div><br clear="none"/></div><div><span style="text-decoration: underline;">Process</span> <span style="text-decoration: underline;">API</span></div><div>Here is a general overview of what must be include in any interface of an operating system.</div><ul><li><strong>Create</strong> - OS's should be able to create new process (ie. double-clicking an application)<br clear="none"/></li><li><strong>Destroy </strong> - OS's should be able to forcefully kill an running process<br clear="none"/></li><li><strong>Wait </strong>- It can be useful to wait for a process to stop running; thus a waiting interface is often provided<br clear="none"/></li><li><strong>Miscellaneous Control</strong> - Usually there are controls other than killing or waiting for a process such as suspending a process and resuming it<br clear="none"/></li><li><strong>Status </strong>- There are usually interfaces to get status information about a process such as how long it has run for and it's state</li></ul><div><br/></div><div><u>Process Creation</u></div><div>How are programs transformed into processes? How does an OS get a program up and running?</div><ul><li>The first thing the OS must do is <b>load</b> it's (the programs) <b>code</b> and any <b>static data</b> (e.g. initialized variables) into the <b>address space</b> of the process.</li><li>Programs initially reside in <b>disk</b> or <b>flash-based SSDs</b> in some kind of <b>executable format</b> - so loading requires the OS to read those bytes from disk and put it into memory</li><li>In early (simple) operating systems, the loading process is done <b>eagerly</b> (all at once before running the program).</li><li>Modern operating systems load programs <b>lazily</b> (by loading pieces of code or data only as they are needed during program execution)</li><li>After loading there are a few other things must do. Some memory must be allocated for the programs <b>stack</b>.</li><li style="list-style: none; display: inline"><ul><li>The OS will also likely initialize the stack with arguments, such as arguments to main (i.e., <b>argc</b> and <b>argv</b> in c)</li></ul></li><li>The OS may also create some memory for the program's <b>heap</b></li><li style="list-style: none; display: inline"><ul><li>The heap will be small at first, but when a program uses <b>malloc</b> for example, the OS may get involved and allocate more memory to the process</li></ul></li><li>The OS may also do I/O setup</li><li>After these steps, the OS has set the stage for program execution. It's last step is to start the program running at the entry point (such as <b>main()</b>). By jumping to main(), the OS transfers control of the CPU to the newly-created process, and thus the program begins executing</li></ul><div><br/></div><div><u>Process States</u></div><ul><li>In a simplified view, a process can be in one of 3 states</li><li style="list-style: none; display: inline"><ul><li><b>Running</b> - In the running state, a process is running on a processor (it is executing instructions)</li><li><b>Ready</b> - In the ready state, the process is read to run (but the OS has chosen not to run it at this moment)</li><li><b>Blocked</b> - In the blocked state, a process has performed some kind of operation that makes it not ready to run until some other event takes place. (E.g. when a process initiates an I/O request to a disk, it becomes blocked so some other process can use the processor)</li></ul></li><li>Process that are ready and are moved to running means the process has been <b>scheduled</b>. Processes that move from running to ready means it has been <b>descheduled.</b> When a process is <b>blocked</b> it awaits some event such as I/O being finished until it moves to the <b>ready</b> state again. Below is a graph of the states.</li></ul><div><b><br/></b></div><div><b><br/></b></div><div>                                               <img src="The Abstraction The Process_files/Image.png" type="image/png" style="height: auto;"/></div><div>                        <b>Note:</b> the I/O: initiate and I/O: done is just a single example in this case.</div><div><br/></div><div><u>Data Structures</u></div><ul><li>The OS is a program that, just like any other program, will use data structures to keep track of information</li><li>For example, to track the state of each process the OS will most likely have a <b>process list</b> for all processes that are <b>ready</b>, as well as some additional info to track which process is running.</li><li>The OS must also track (in some way) <b>blocked</b> process.</li><li>Some things that an OS tracks about a process are the register context and it's state</li><li style="list-style: none; display: inline"><ul><li>The <b>register context</b> will hold, for a stopped process, the contents of its register state</li><li>When a process is stopped, its register state will be saved to this memory location and by restoring the registers the OS can resume running the process. (This is a technique known as a <b>context switch</b>)</li></ul></li><li>There are some other states a process can be in other than the 3 listed.</li><li style="list-style: none; display: inline"><ul><li>Sometimes a process will have an <b>initial</b> state that the process is in when it is being created</li><li>A process could be in a <b>final</b> state where it has exited but has not yet been cleaned up (also known as a <b>zombie</b> state in UNIX)</li><li>The final state can be useful since it allows the <b>parent</b> (or some other processes) to examine the return code of the process to see if the process executed successfully. When finished, the parent will make one final call (<b>wait()</b>) to wait for the completion of the child, and to tell the OS to clean up any data structures that referred to the now extinct process</li></ul></li></ul></span>
</div></body></html> 